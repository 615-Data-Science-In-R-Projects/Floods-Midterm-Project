---
title: "Floods"
format: html
editor: visual
---

```{r}
#Intializing relevant libraries

library(tidyverse)
```

## Introduction

## Data Cleaning

```{r}
#Reading in the data from NOAA
storms<- read.csv("StormEvents_details_2021.csv")

#Filtering so that we only look at storms:
floods<- storms |> filter(str_detect(EVENT_TYPE,"Flood")==TRUE)

```
 So immediately, a few things stand out: the way the dates are coded and the fact that they're coded twice and differently. 
 What I'll shoot for here is to have dates as month, day and time and also as a single datetime
 
```{r}
#floods_date_time<- floods_raw |> select(-c(BEGIN_YEARMONTH,BEGIN_DAY,BEGIN_TIME,
                                          # END_YEARMONTH,END_DAY,END_TIME))

#We'll start by cleaning begin date and end date to date-time format so we can join with the fema data

floods1<- floods |> mutate(incidentBeginDate= 
            dmy(str_sub(BEGIN_DATE_TIME,1,
          str_locate(BEGIN_DATE_TIME," ")[2])),.before =BEGIN_DATE_TIME)

floods1<- floods1 |> mutate(incidentEndDate= 
            dmy(str_sub(END_DATE_TIME,1,
          str_locate(END_DATE_TIME," ")[2])),.before =END_DATE_TIME)

#We can also add a time column. We'll adjust this for timezones later

floods1<- floods1 |> mutate(incidentBeginTime = 
          hms(str_sub(BEGIN_DATE_TIME,
          str_locate(BEGIN_DATE_TIME," ")[2],)), .before=BEGIN_DATE_TIME)

floods1<- floods1 |> mutate(incidentEndTime = 
          hms(str_sub(END_DATE_TIME,
          str_locate(END_DATE_TIME," ")[2],)), .before=END_DATE_TIME)
```
 
After dates, the damages columns need fixing.  

```{r, echo=FALSE}
#Property damage

#First lets check if there are any entries in property damage that don't end in
#either K or M
floods$DAMAGE_PROPERTY<- str_trim(floods$DAMAGE_PROPERTY, side="both")
dim(floods |> filter(str_detect(DAMAGE_PROPERTY,"K")==TRUE |
                       str_detect(DAMAGE_PROPERTY,"M")==TRUE))[1]

#This isn't the same as the number of rows in floods. A little messing around
#tells us that this is because some values are NA. 

#So now we know that every entry in this column ends in k or m or is NA, we can 
#retrieve the number and conditionally multiply by 1000 or a million

floods$DAMAGE_PROPERTY<- ifelse(str_detect(floods$DAMAGE_PROPERTY,"K")==TRUE,
                    as.numeric(str_sub(floods$DAMAGE_PROPERTY,0,-2))*1000,
                    ifelse(str_detect(floods$DAMAGE_PROPERTY,"M")==TRUE,
                    as.numeric(str_sub(floods$DAMAGE_PROPERTY,0,-2))*1000000,
                    NA))

#We can do the same for crop_damage

floods$DAMAGE_CROPS<- ifelse(str_detect(floods$DAMAGE_CROPS,"K")==TRUE,
                    as.numeric(str_sub(floods$DAMAGE_CROPS,0,-2))*1000,
                    ifelse(str_detect(floods$DAMAGE_CROPS,"M")==TRUE,
                    as.numeric(str_sub(floods$DAMAGE_CROPS,0,-2))*1000000,
                    NA))

```

Let's join the floods data with the combined fema data:

```{r, echo=FALSE}
fema<- read_csv("DisasterDeclarationsSummaries.csv")
fema_floods<- fema |> filter(str_detect(incidentType, "Flood")==TRUE) |> 
                  filter(str_detect(incidentBeginDate,"2021")==TRUE)

fema_assistance<- read.csv("FemaWebDisasterSummaries.csv", header = TRUE)
fema_combined<- suppressWarnings(left_join(x=fema_floods,y=fema_assistance, by="disasterNumber"))

fema_combined<-fema_combined |> select(-c(lastRefresh.x,lastRefresh.y,hash.x,hash.y,id.x, id.y))

#We'll start by trying to join by begin and end dates. 

floods_fema_combined<- left_join(x=floods1, y=fema_combined, by="incidentBeginDate")

#removing redundant columns

floods_fema_combined<-floods_fema_combined |> select(-c(BEGIN_YEARMONTH:END_TIME,YEAR,MONTH_NAME,MAGNITUDE,
                                  MAGNITUDE_TYPE,CATEGORY:TOR_OTHER_CZ_NAME))

#Filtering out columns for which we don't have fema data

floods_fema_combined_noNA<- floods_fema_combined |>
  filter(is.na(declarationType)==FALSE)
```

We can also join this data with poverty data from the census. This data has to be cleaned first:

```{r}

```

